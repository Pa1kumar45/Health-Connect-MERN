================================================================================
HEALTH-CONNECT INTERVIEW Q&A
================================================================================
Tech Stack: ReactJS, NodeJS, WebRTC, MongoDB, Socket.IO | Feb 2025 - May 2025
================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
SOCKET.IO - Real-time Chat (<50ms latency)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: What is Socket.IO and why use it?
A: JavaScript library for bidirectional real-time communication. Provides auto-
   reconnection, room-based messaging, and fallback to HTTP polling if WebSocket 
   blocked. Messages delivered in <50ms, saved to MongoDB for persistence.

Q: How does it work in your project?
A: Users join private rooms by ID. When User A sends a message, server emits to 
   User B's room via socket.to(receiverId).emit("newMessage"). Message saved to 
   MongoDB and pushed to frontend. Auto-reconnects with exponential backoff on 
   network drops.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
WEBRTC - P2P Video Calls (<100ms latency, $0 cost)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Why WebRTC over Twilio?
A: Free, open-source P2P video framework. Twilio costs $0.004/min ($240/month 
   for 1000 hours). WebRTC streams directly between users (no server bandwidth), 
   <100ms latency, full control over connections.

Q: How does signaling work?
A: Use Socket.IO to exchange SDP (session descriptions) and ICE candidates 
   (network addresses). Flow: Caller creates offer → sends via socket → Callee 
   creates answer → exchange ICE candidates → P2P connection established.

Q: How handle connection failures?
A: Monitor ICE states. Queue candidates if they arrive before remote SDP set. 
   Only cleanup on "failed"/"closed" states (not "disconnected" which is temporary).

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
JWT AUTHENTICATION - Stateless, 7-day sessions
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: How does JWT work?
A: Generate token with jwt.sign({ userId }, SECRET, { expiresIn: "7d" }). Set as 
   HTTP-only cookie. Middleware verifies with jwt.verify(), decodes userId, 
   fetches user from MongoDB, attaches to req.user. Token verified in <5ms.

Q: Why JWT over sessions?
A: Stateless (no server-side storage), easier horizontal scaling. Sessions need 
   Redis/DB for storage. JWT contains all data, works with mobile apps and 
   microservices.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
HTTP-ONLY COOKIES - XSS Protection
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Why HTTP-only cookies?
A: JavaScript can't access (document.cookie returns empty). Prevents XSS token 
   theft. Automatically sent with requests—no manual Authorization headers.

Q: Cross-domain cookies (Vercel + Render)?
A: Require sameSite: "none" + secure: true (HTTPS only). Tells browser to send 
   cookies cross-origin. Use sameSite: "lax" + secure: false for localhost.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BCRYPT HASHING - 10 rounds (~100ms, HIPAA compliant)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: What is bcrypt and why 10 rounds?
A: Password hashing with built-in salting. 10 rounds = hash 2^10 (1,024) times. 
   Takes ~100ms—fast for UX, slow for brute force. Industry standard 10-12 rounds.

Q: How does salting work?
A: Generates random 22-char salt per password. Salt prepended before hashing, 
   stored in output. Identical passwords produce different hashes. Prevents 
   rainbow table attacks.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
CLOUDINARY CDN - 85% bandwidth reduction, <50ms load
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Why Cloudinary?
A: Cloud image hosting with 200+ global edge servers. Reduces bandwidth 85%, 
   load times to <50ms. Auto-optimizes to WebP. Free tier: 25GB/month (supports 
   10,000 users).

Q: Upload process?
A: Frontend converts to Base64 → backend uploads with transformations (200x200px) 
   → Cloudinary returns secure URL → save to MongoDB → <img> loads from CDN.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
REACTJS + TYPESCRIPT - Component reusability, type safety
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Why React over Angular?
A: Largest ecosystem, 40KB bundle vs Angular's 500KB. Junior devs productive in 
   2 weeks vs 3 months. Simpler architecture for small teams (2-3 devs).

Q: State management?
A: React Context API for global state. Three contexts: AppContext (user, socket), 
   MessageContext (chat, unread counts), VideoCallContext (peer connection, call 
   status). Avoids prop drilling across 16 components.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
NODEJS + EXPRESS - Non-blocking I/O, 10,000+ concurrent users
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Why Node.js?
A: Event-driven, non-blocking I/O. Doesn't wait for DB queries—handles other 
   requests via callbacks. Enables 10,000+ concurrent connections. JavaScript 
   everywhere (frontend + backend).

Q: Express.js role?
A: Minimalist framework for REST APIs. Provides routing, middleware (auth, error 
   handling), request/response. <10KB overhead, integrates Socket.IO/JWT/MongoDB.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MONGODB - NoSQL, 95% faster queries with indexes
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Why MongoDB over PostgreSQL?
A: NoSQL flexibility for variable medical data. Nested documents (allergies, 
   medications) instead of separate tables. No JOINs—one query fetches patient 
   record in <20ms. Add fields without migrations.

Q: Query optimization?
A: Compound indexes: appointmentSchema.index({ doctorId: 1, date: 1 }). Reduced 
   queries from 200ms (full scan) to <10ms (B-tree lookup)—95% improvement.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MEDICAL RECORDS - HIPAA-compliant data privacy
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Data privacy strategy?
A: 7-layer security: (1) JWT auth, (2) Role-based access, (3) HTTPS encryption, 
   (4) MongoDB Atlas encryption at rest, (5) HTTP-only cookies prevent XSS, 
   (6) Bcrypt password hashing, (7) No logging of sensitive data.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
APPOINTMENTS - Conflict detection, lifecycle tracking
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Prevent double-booking?
A: Query existing appointments before creating: 
   Appointment.find({ doctorId, date, status: { $in: ["pending", "scheduled"] } })
   Compound index makes check <10ms. Doctor availability limits selectable slots.

Q: Appointment lifecycle?
A: Pending (patient books) → Scheduled (doctor accepts) → Active (during call) 
   → Completed (ends) → or Cancelled. Filter by status in dashboard.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
DEPLOYMENT - Vercel + Render + MongoDB Atlas ($0 dev cost)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Deployment stack?
A: Frontend on Vercel (auto-deploy, global CDN, <20ms load). Backend on Render 
   (free tier with auto-scaling). MongoDB Atlas (512MB free). Cloudinary (25GB 
   free). Total: $0/month dev, ~$20/month production.

Q: Scale to 10,000 users?
A: (1) Database sharding by region, (2) Load balancing (3 backend instances + 
   Nginx), (3) Redis caching (70% DB load reduction), (4) Socket.IO Redis adapter 
   for multi-server sync, (5) Cloudflare CDN for React bundle.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
CHALLENGES OVERCOME
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Q: Hardest challenge?
A: Cross-domain cookies (Vercel ↔ Render). Browsers blocked cookies—solved with 
   sameSite: "none" + secure: true. Required CORS credentials config. Only 
   appeared in production, took 2 days to debug.

Q: WebRTC debugging?
A: ICE candidates arrived before remote SDP set → "InvalidStateError". Fixed 
   with candidate queue. Also, "disconnected" ICE state is temporary—only cleanup 
   on "failed"/"closed" states.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
QUANTIFIABLE METRICS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Chat latency: <50ms (Socket.IO WebSocket)
• Video latency: <100ms (WebRTC P2P)
• DB queries: <10ms (95% improvement from 200ms with indexes)
• Image load: <50ms (Cloudinary CDN, 85% bandwidth reduction)
• Password hashing: ~100ms (bcrypt 10 rounds)
• JWT verification: <5ms (stateless)
• Frontend bundle: 350KB gzipped
• Backend response: <100ms avg
• Cloudinary optimization: 500KB → 75KB per avatar

================================================================================
40+ Questions | Keywords: Socket.IO, WebRTC, JWT, HTTP-only cookies, bcrypt,
Cloudinary, React, Node.js, MongoDB, Real-time, Medical records, Appointments
================================================================================
